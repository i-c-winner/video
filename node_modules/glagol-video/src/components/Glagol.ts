import { getRandomText } from '../plugins/getRandomText';
interface IHandlers {
  [key: string]: ((...args: any[]) => void)[]
} ;
class Glagol {
  private xmpp: any;
  private webRtc: RTCPeerConnection;
  private readonly userNode: string;
  private candidates: RTCIceCandidate[];
  private roomName: string;
  private displayName: string;
  private handlers: IHandlers


  constructor(props: {
    xmpp: any,
    webRtc: RTCPeerConnection,
    userNode: string,
    roomName: string,
    displayName: string,
    handlers: IHandlers
  }) {
    this.xmpp = props.xmpp;
    this.webRtc = props.webRtc;
    this.userNode=props.userNode
    this.roomName=props.roomName
    this.displayName=props.displayName
    this.handlers=props.handlers
    this.candidates=[]
  }

  addHandlers() {
    this.xmpp.addHandler(this.xmppHandlerMessage, null, 'message');
    this.xmpp.addHandler(this.xmppHandlerPresence, null, 'presence');
    this.xmpp.addHandler(this.xmppHandlerIqTypeResult, null, 'iq', 'result');
  }

  register() {

    return new Promise((resolve, reject)=>{
      const callback = (status: number): void => {
        // @ts-ignore
        if (status === Strophe.Status.REGISTER) {
          // fill out the fields
          this.xmpp.register.fields.username = this.userNode;
          this.xmpp.register.fields.password = getRandomText(5);
          // calling submit will continue the registration process
          this.xmpp.register.submit();
          //@ts-ignore
        } else if (status === Strophe.Status.REGISTERED) {
          console.info("registered!");
          // calling login will authenticate the registered JID.
          this.xmpp.authenticate();
          //@ts-ignore
        } else if (status === Strophe.Status.CONFLICT) {
          console.info("Contact already existed!");
          //@ts-ignore
        } else if (status === Strophe.Status.NOTACCEPTABLE) {
          console.info("Registration form not properly filled out.");
          //@ts-ignore
        } else if (status === Strophe.Status.REGIFAIL) {
          console.info("The Server does not support In-Band Registration");
        } else if (status === Strophe.Status.CONNECTED) {
          console.info('Соединение XMPP установленно');
          resolve(true)
        } else {
          // Do other stuff
        }
      };
      this.xmpp.register.connect('prosolen.net', callback);
    })
  }
  setCandidate(candidate: RTCIceCandidate) {
    this.candidates.push(candidate)

  }
  resetCandidates() {
    this.candidates=[]
  }
  getCandidates () {
    return this.candidates
  }
  pcHandlerIceCandidate(event: any) {
    if (event.candidate) {
      // @ts-ignore
      const candidate = btoa(JSON.stringify({ candidate: event.candidate }));
      const message = new Strophe.Builder('message', {
        to: `${this.roomName}@conference.prosolen.net/focus`,
        type: 'chat'
      }).c('body').t(candidate);
      this.sendMessage(message);
    }
    return true
  }

  pcHandlerOnTrack(event: any) {
    this.emit('addTrack', event);
return true
  }

  xmppHandlerMessage = (stanza: Element) => {
    const context = this;
    const bodyText = Strophe.getText(stanza.getElementsByTagName('body')[0]);
    const jimble = stanza.getElementsByTagName('jimble')[0];
    const jimbleText = Strophe.getText(jimble);
    switch (bodyText) {
      case 'add_dashboard': {
        break;
      }
      case 'invitation_reply':
        navigator.mediaDevices.getUserMedia({
          video: true,
          audio: true
        }).then((stream) => {
          stream.getTracks().forEach((track) => {
            this.webRtc.addTrack(track);
          });
          this.connectdWasChanged(jimbleText);
        });

        break;
      case 'add_track': {
        this.connectdWasChanged(jimbleText);
        break;
      }
      case 'ice_candidate': {
        const candidate = new RTCIceCandidate(JSON.parse(atob(jimbleText)));
        if (this.webRtc.remoteDescription) {
          this.webRtc.addIceCandidate(candidate);
        } else {
          this.setCandidate(candidate);
        }
        break;
      }
      case 'remove_track': {
        this.connectdWasChanged(jimbleText);
        this.emit('removeTrack', stanza);
        break;
      }
      case 'offer_dashboard': {
        break;
      }
      case 'send_dashboard': {
        this.connectdWasChanged(jimbleText);
        this.emit('sendSharing');

        break;
      }
      case 'remove_dashboard': {
        this.connectdWasChanged(jimbleText);
        this.emit('removeSharing', stanza);
        break;
      }
      case 'offer_download': {
        const idRemote = jimble.getAttribute('id_remote');

        break;
      }
      default: {
        console.info('message with unknown action');
      }
    }
    console.log(stanza, 'Stanza message');
    return true
  };

  xmppHandlerIq = (stanza: Element) => {

    return true;
  };

  xmppHandlerPresence = (stanza: Element) => {
    const jingle = stanza.getElementsByTagName('jingle');
    try {
      const x = stanza.getElementsByTagName('x');
      try {
        const statuses: Element[] = Array.from(x[1].getElementsByTagName('status'));
        if (statuses[0] !== null) {
          if (Number(statuses[0].getAttribute('code')) === 201) {
            this.validateRoom();
          } else if (Number(statuses[0].getAttribute('code')) === 100) {
            this.invitateRoom();
          }
        }
      } catch (e) {
      }
    } catch (e) {
    }
    console.log(stanza, "Stanza");
    return true
  };

  xmppHandlerIqTypeResult = (stanza: Element) => {
    try {
      const from = stanza.getAttribute('from') || [];
      if (stanza !== null) {
        const attribute = stanza.getAttribute('from');
        if (attribute) {
          const roomName = attribute.split('@')[0];
          if (roomName === this.roomName) this.invitateRoom();
        }

      }
    } catch (e) {

    }
    return true
  };

  sendMessage(message: Strophe.Builder) {
    this.xmpp.send(message);
  }

  connectdWasChanged(description: string) {
    this.webRtc.setRemoteDescription(JSON.parse(atob(description))).then(() => {
      this.getCandidates().forEach((candidate) => this.webRtc.addIceCandidate(candidate));
      this.resetCandidates();
      return this.webRtc.createAnswer({
        iceRestart: true
      });
    }).then((answer) => {
      const answer64 = btoa(JSON.stringify({ answer }));
      this.webRtc.setLocalDescription(answer).then(() => {
        const message: Strophe.Builder = new Strophe.Builder('message', {
          to: `${this.roomName}@conference.prosolen.net/focus`,
          type: 'chat'
        }).c('body').t(answer64);
        this.sendMessage(message);
      }).catch((error) => {
        console.error(new Error('error'), error);
      });
    });
  }
  createRoom() {
    const message = new Strophe.Builder('presence', {
      to: `${this.roomName}@conference.prosolen.net/${this.userNode}`,
    }).c('x', {
      xmlns: 'http://jabber.org/protocol/muc'
    });
    this.sendMessage(message);
  }

  validateRoom() {
    const message = new Strophe.Builder('iq', {
      // from: `${this.roomName}@prosolen.net/${this.userNode}`,
      id: this.userNode,
      to: `${this.roomName}@conference.prosolen.net`,
      type: 'set'
    }).c('query', {
      xmlns: 'http://jabber.org/protocol/muc#owner'
    }).c('x', {
      xmlns: 'jabber:x:data',
      type: 'submit'
    });
    this.sendMessage(message);
  }

  invitateRoom() {
    const invitation = {
      action: "INVITATION",
      tracks: {
        audio: true,
        video: true
      }
    };
    const inviteMessageB64 = btoa(JSON.stringify(invitation));
    const message = new Strophe.Builder('message', {
      to: 'focus@prosolen.net/focus',
      type: 'chat',
      xmlns: 'jabber:client'
    }).c('x', {
      xmlns: 'jabber:x:conference',
      jid: `${this.roomName}@conference.prosolen.net`
    }).up().c('nick', {
      xmlns: 'http://jabber.org/protocol/nick'
    }).t(this.displayName).up().c('jimble').t(inviteMessageB64);
    this.sendMessage(message);
  }
  emit = (name: string, ...args: any[]) => {
    try {
      this.handlers[name].forEach((handler) => {
        handler(args);
      });
    } catch (e) {
      console.info(`Listener ${name} note found: `, e);
    }

  };
}

export { Glagol };
