type TSendMessage = (message: Strophe.Builder) => void

const webRtc = {
  Strophe: undefined,
  listeners: {},
  instance: new RTCPeerConnection(),
  init: function (url: any) {
    this.instance = new RTCPeerConnection(url);
    this.peerConnectionAddHandlers();
  },
  peerConnectionAddHandlers() {
    const pc = this.instance;
    pc.ontrack = (event) => {
      console.log('ontrack');
      const type = event.streams[0].id.split('-')[0];
      if (type === 'audio' || type === 'video') {
        // this.emit('addTrackToSource', {
        //   id: event.receiver.track.id,
        //   type
        // });
      } else if (type === 'dashboard') {
        // this.emit('addSharingToSource', {
        //   id: event.receiver.track.id,
        //   type
        // });
      }


      event.streams[0].onremovetrack = (event) => {
        // this.emit('removeRemoteTrackFormSource', event.track.id);
      };
    };
    // pc.ondatachannel = (event) => {
    //   createListeners(event.channel);
    //   channel.init(event.channel);
    //
    //   function createListeners(chanelInstance: RTCDataChannel) {
    //     chanelInstance.onmessage = (message) => {
    //       channel.putChunks(message);
    //     };
    //   }
    // };
    pc.onnegotiationneeded = (event) => {
    };
    pc.onsignalingstatechange = (event) => {
    };
    pc.onconnectionstatechange = (event: any) => {
      console.log('OKKKKKK');
      this.emit('pcOnconnectionStateChange');
    };
    pc.onicecandidate = (event) => {
      console.log(event, 'EVENT')
    };
  },
  create: function (action: TSendMessage, roomName?: string, userNode?: string) {

  },
  validate(action: TSendMessage, roomName: string, userNode: string) {

  },
  invite(action: TSendMessage, roomName: string, displayName: string) {

  },

  on: function (name: string, callback: (...args: any[]) => void) {
    if (!this.listeners[name]) {
      this.listeners[name] = [];
    }
    this.listeners[name].push(callback);
  },
  off: function (name) {
    if (this.listeners[name]) {
      this.listeners[name] = [];
    } else {
      console.error((error: any) => new Error(error), `Слушатель ${name} не существует`);
    }
  },
  emit: function (name, ...args) {
    if (!this.listeners[name]) {
      console.error((error: any) => new Error(error), `Слушатель ${name} не существует`);
    }
    this.listeners[name].forEach((listener) => {
      listener(args);
    });
  },
  getRoom: function () {
    return this.instance;
  }
};
export { webRtc };
