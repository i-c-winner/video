import { getRandomText } from '../plugins/getRandomText';

type TCallback = (...args: any[]) => void
const connection: {
  instance: any,
  addHandlers: () => void,
  creating: (user: string, node: string) => void,
  sendMessage: (message: Strophe.Builder) => void,
  listeners: {
    [key: string]: TCallback[]
  },
  on: (name: string, callback: TCallback) => void,
  off: (name: string) => void,
  emit: (name: string, ...args: any[]) => void

} = {
  instance: null,
  listeners: {},
  addHandlers: function () {
    const handlerMessage = (stanza: Element) => {
      const bodyText = Strophe.getText(stanza.getElementsByTagName('body')[0]);
      const jimble = stanza.getElementsByTagName('jimble')[0];
      const jimbleText = Strophe.getText(jimble);
      switch (bodyText) {
        case 'add_dashboard': {
          break;
        }
        case 'invitation_reply':
          navigator.mediaDevices.getUserMedia({
            video: true,
            audio: true
          }).then((stream) => {
            stream.getTracks().forEach((track) => {
              this.emit('invitation_reply', track, stream);
            });
            this.emit('addIceCandidate', jimbleText);
          });

          break;
        case 'add_track': {

          break;
        }
        case 'ice_candidate': {
          const candidate = new RTCIceCandidate(JSON.parse(atob(jimbleText)));
         this.emit('pushCandidate', candidate)
          break;
        }
        case 'remove_track': {

          break;
        }
        case 'offer_dashboard': {
          break;
        }
        case 'send_dashboard': {


          break;
        }
        case 'remove_dashboard': {

          break;
        }
        case 'offer_download': {
          const idRemote = jimble.getAttribute('id_remote');

          break;
        }
        default: {
          console.info('message with unknown action');
        }
      }
      console.log(stanza, 'Stanza message');
      return true;
    };
    const handlerIqTypeResult = () => {
      this.emit('invite');
      return true;
    };
    const handlerMessageGroupChat = (stanza: Element) => {
      try {
        const body = stanza.getElementsByTagName('body')[0];
        const text = Strophe.getText(body);
        const jingle = stanza.getElementsByTagName('jingle')[0];
        const id = jingle.getAttribute('id');
        const author = jingle.getAttribute('author');
      } catch (e) {

      }
      return true;
    };
    const handlerPresence = (stanza: Element) => {
      const jingle = stanza.getElementsByTagName('jingle');
      try {
        const x = stanza.getElementsByTagName('x');
        try {
          const statuses: Element[] = Array.from(x[1].getElementsByTagName('status'));
          if (statuses[0] !== null) {
            if (Number(statuses[0].getAttribute('code')) === 201) {
              this.emit('validateRoom');
            } else if (Number(statuses[0].getAttribute('code')) === 100) {
              this.emit('invite');
            }
          }
        } catch (e) {
        }
      } catch (e) {
      }
      console.log(stanza, "Stanza");
      return true;
    };
    this.instance.addHandler(handlerMessage, null, 'message', 'chat');
    this.instance.addHandler(handlerIqTypeResult, null, 'iq', 'result');
    this.instance.addHandler(handlerPresence, null, 'presence');
    this.instance.addHandler(handlerMessageGroupChat, null, 'message', 'groupchat');
  },
  creating: function (user, node) {
    const callback = (status: number): void => {
      // @ts-ignore
      if (status === Strophe.Status.REGISTER) {
        // fill out the fields
        this.instance.register.fields.username = user;
        this.instance.register.fields.password = getRandomText(5);
        // calling submit will continue the registration process
        this.instance.register.submit();
        //@ts-ignore
      } else if (status === Strophe.Status.REGISTERED) {
        console.info("registered!");
        // calling login will authenticate the registered JID.
        this.instance.authenticate();
        //@ts-ignore
      } else if (status === Strophe.Status.CONFLICT) {
        console.info("Contact already existed!");
        //@ts-ignore
      } else if (status === Strophe.Status.NOTACCEPTABLE) {
        console.info("Registration form not properly filled out.");
        //@ts-ignore
      } else if (status === Strophe.Status.REGIFAIL) {
        console.info("The Server does not support In-Band Registration");
      } else if (status === Strophe.Status.CONNECTED) {
        console.info('Соединение XMPP установленно');
        connection.addHandlers();
        this.emit('connected');
      } else {
        // Do other stuff
      }
    };
    this.instance.register.connect('prosolen.net', callback);
  },
  sendMessage: function (message) {
    this.instance.send(message);
  },
  on: function (name: string, callback: (...args: any[]) => void) {
    if (!this.listeners[name]) {
      this.listeners[name] = [];
    }
    this.listeners[name].push(callback);
  },
  off: function (name) {
    if (this.listeners[name]) {
      this.listeners[name] = [];
    } else {
      console.error((error: any) => new Error(error), `Слушатель ${name} не существует`);
    }
  },
  emit: function (name, ...args) {
    if (!this.listeners[name]) {
      console.error((error: any) => new Error(error), `Слушатель ${name} не существует`);
    }
    this.listeners[name].forEach((listener) => {
      listener(args);
    });
  },
};

export { connection };
